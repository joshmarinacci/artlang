@board("canvas")

var screen = new KCanvas(0,0,1024,768)
var dpad = new DPadWrapper()
var grid = MDArray([20,20])
grid.fill(0)
var dir = [1,0]
var pos = [10,10]
var tail = []
tail.push_end(pos)
var PALETTE = [RED,GREEN,BLUE]

var count = 0

//TODO: i shouldn't need the return here
fun nth(a,b) { return (a mod b) == 0 }

@type('start',setup)
fun setup() {
    //set the edges
    // grid[0,?].fill(1)
    reset()
    print("done starting")
}
fun reset() {
    pos = [10,10]
    tail = []
    grid.fill(0)
    //TODO: need better slice syntax
    grid.slice([0,null]).fill(1)
    grid.slice([19,null]).fill(1)
    grid.slice([null,0]).fill(1)
    grid.slice([null,19]).fill(1)
}


//TODO: make this use a real keyboard / dpad object
var dpad_current = [1,0]
@type('loop',forever)
fun forever() {
    var newdir = dpad.current() // turns [-1,-1] to [1,1]
    if ((newdir.get1(0) == 0) and (newdir.get1(1) == 0)) {
        print("its empty",dir)
    } else {
        dir = newdir
    }
    //TODO: implement +=
	pos = pos + dir
	//print("dir",dir.toJSFlatArray(),'pos',pos)
	var px = pos.get1(0)
	var py = pos.get1(1)
	//TODO: array getter syntax
	//grid[pos] is the same as grid[pos[0],pos[1]], or etc.
    if (grid.get2(pos.get1(0),pos.get1(1)) > 0) {
		print("you died")
    	return reset()
    }
    tail.push_end(pos)
    grid.set2(pos.get1(0), pos.get1(1), 2)
	grid.every(@(v,x,y)=> {
	    screen.fillRect(Rect(x:x*10, y:y*10, w:10, h:10),PALETTE.get1(v))
    })
    tail.every(@(v,i) => {
        var color = PALETTE.get1(2)
        var rect = Rect(x:v.get1(0)*10, y:v.get1(1)*10, w:10, h:10)
	    screen.fillRect(rect,color)
    })
    if (not nth(count,6)) {
        var pp = tail.pop_start()
        grid.set2(pp.get1(0), pp.get1(1), 0)
    }

    count = count + 1
    return wait(0.2)
}
